applyRules
==========

描述
    将策略中的规则应用到任意市场数据。该函数的典型使用是通过applyStrategy调用。这种模式下，函数将被调用两次，一次以参数path.dep=FALSE； 然后再以跨越mktdata 对象时间索引的方式。

用法
::

    applyRules(portfolio, symbol, strategy, mktdata, Dates=NULL, indicators=NULL, signals=NULL, parameters=NULL, ..., path.dep=TRUE)

参数
    :portfolio: 将订单薄与之联系起来的投资组合的文本名字
    :symbol: 查找发现订单的证券标识符。任何关联价格对象的名字（xts价格，通常是OHLC）必须与此匹配
    :strategy: 一个要加入规则的“strategy”类型对象
    :mktdata: 一个包含市场数据的xts对象。根据规则不同，可能需要是OHLCV 或BBO格式，也许包括指标和信号信息
    :Dates: 缺省为NULL，用来迭代的时间戳列表，如果path.dep=FALSE ，则被忽略
    :indicators: 通过指标输出没有包含在mktdata 对象中，它也许单独作为一个xts对象或列表传递
    :signals: 通过信号输出没有包含在mktdata 对象中，它也许单独作为一个xts对象或列表传递
    :parameters: 策略解析期间用到的参数的命名列表，缺省为NULL。仅当需要特殊的名字以避免参数冲突时需要
    :...: 任何其它要传递的参数
    :path.dep: TRUE/FALSE规则是否为路径依赖型，缺省为 TRUE ，参见说明部分

说明
    个别规则函数或许需要使用?-发挥hold和holdtill 8变量的作用。这些很可能由风险规则实现。当hold==TRUE ，任何开放订单仍将被处理（订单不会被自动取消，但是没有新订单被输入）。type=’risk’规则在hold期间仍将发挥作用。注意，hold必须通过定制规则设置。我们倾向于在订单或风险规则中设置hold。

    quantstrat有一些非常重要的逻辑专门用于处理路径依赖规则的执行。这些代码/逻辑的大部分就在该函数中。

    该函数，与ruleOrderProc、addOrder和applyStrategy一道，在连接到真实的市场基础设施时很可能需要被替换。

    **降维提升性能**

    评价路径依赖规则时，在增加一个新的规则之前，需要停止之前的部分。最简单的办法，也是我们最开始使用的，是检查应用到市场数据时间序列上每个观测值的规则。还有需要这种方法的情况，但是我们希望尽可能地限制它们。循环，在R中通常不鼓励用，应用在评估策略的高频数据上，可能会造出完全不可接受的结果。

    我们采用的解决方案是利用我们做知道的策略以及策略所发出（或将发出）订单来降低维数问题。

    正如在add.rule中所讨论的，降维的第一步是在时间序列中查找信号引起策略输入或改变订单的位置。这创建一个必须被解析的时间戳索引。该索引长度应该比全部观测值的数量短得多。quantstrat将对每个我们之前算出策略或许要做些什么的索引运行applyRules。

    降维的第二步工作在订单薄上。如果有开放订单，我们需要算出它们何时会被填写（get filled）。对市价单（market orders），这是另一个观测值；对限价单（limit orders），我们可以定位订单提交之后的时间戳索引，看订单何时穿越9（cross）。我们将把该索引添加到要解析的索引列表。当然，不能保证那时订单还保持开放，由于风险规则该交易没有保留（on hold），或者其它什么没有被干涉。添加该索引到列表仅仅告诉applyRules中的循环（loop）：规则（包括订单处理规则）需要在那个索引处检查一下，看看是否有什么需要发生。

    对追踪订单，情况在某种意义上更加复杂。追踪订单可能会在每个新观测值上移动，由addOrder中说明的方法而定。这样的订单穿越时要加速解析，我们需要将上述针对限价单的可能逻辑与一些处理追踪单的额外逻辑结合起来。从解析订单价格也许会在何时移动开始，然后在当前索引与订单可能移动点之间检查市场数据。如果有一个（可能的）穿越，我们将该索引插入索引表中以备检查。如果没有，我们插入下一个可能移动的索引。

    应该注意到，这种降维方法在数据中没有预见性（“look ahead”）。预见仅在普通路径依赖过程中订单已经输入之后，所以不会引入倾向性。

参考
    add.rule applyStrategy
